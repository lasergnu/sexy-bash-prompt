#!/usr/bin/env bash
# Jay's Bash prompt
# https://github.com/lasergnu/sexy-bash-prompt
# Forked from twolfson, https://github.com/twolfson/sexy-bash-prompt
# Forked from gf3, https://gist.github.com/gf3/306785


# If we are on a colored terminal
if tput setaf 1 &> /dev/null; then
    # Reset the shell from our `if` check
    tput sgr0 &> /dev/null

    # If you would like to customize your colors, use
    # # Attribution: http://linuxtidbits.wordpress.com/2008/08/11/output-color-on-bash-scripts/
    # for i in $(seq 0 $(tput colors)); do
    #   echo " $(tput setaf $i)Text$(tput sgr0) $(tput bold)$(tput setaf $i)Text$(tput sgr0) $(tput sgr 0 1)$(tput setaf $i)Text$(tput sgr0)  \$(tput setaf $i)"
    # done

    # Save common color actions
    sbp_bold="$(tput bold)"
    sbp_reset="$(tput sgr0)"

    # If the terminal supports at least 256 colors, write out our 256 color based set
    if [[ "$(tput colors)" -ge 256 ]] &> /dev/null; then
        sbp_user_color="$sbp_bold$(tput setaf 27)"        # BOLD BLUE
        sbp_dir_color="$sbp_bold$(tput setaf 76)"         # BOLD GREEN
        sbp_git_status_color="$sbp_bold$(tput setaf 154)" # BOLD YELLOW
        sbp_git_progress_color="$sbp_bold$(tput setaf 9)" # BOLD RED
    else  # Otherwise, use colors from our set of 8
        sbp_user_color="$sbp_bold$(tput setaf 4)"         # BOLD BLUE
        sbp_dir_color="\033[m"                                         # PLAIN WHITE
        sbp_git_status_color="$sbp_bold$(tput setaf 2)"   # BOLD GREEN
        sbp_git_progress_color="$sbp_bold$(tput setaf 1)" # BOLD RED
    fi
    
    sbp_symbol_color="$sbp_bold"                          # BOLD

else
    # Otherwise, use ANSI escape sequences for coloring
    # If you would like to customize your colors, use
    # DEV: 30-39 lines up 0-9 from `tput`
    # for i in $(seq 0 109); do
    #   echo -n -e "\033[1;${i}mText$(tput sgr0) "
    #   echo "\033[1;${i}m"
    # done

    sbp_reset="\033[m"                                             # WHITE
    sbp_user_color="\033[1;34m"                                      # BLUE
    sbp_dir_color="\033[1;32m"                                       # GREEN
    sbp_git_status_color="\033[1;33m"                                # YELLOW
    sbp_git_progress_color="\033[1;31m"                              # RED
    sbp_symbol_color=""                                              # NORMAL
fi


# Set up symbols
sbp_synced_symbol=" "
sbp_dirty_synced_symbol="* "
sbp_unpushed_symbol="△ "
sbp_dirty_unpushed_symbol="▲ "
sbp_unpulled_symbol="▽ "
sbp_dirty_unpulled_symbol="▼ "
sbp_unpushed_unpulled_symbol="⬡ "
sbp_dirty_unpushed_unpulled_symbol="⬢ "
sbp_symbol="> "

function sbp_get_git_branch() {
    # On branches, this will return the branch name
    # On non-branches, (no branch)
    local ref="$(git symbolic-ref HEAD 2> /dev/null | sed -e 's/refs\/heads\///')"
    [ -n "$ref" ] && echo "$ref" || echo "(no branch)"
}

function sbp_get_git_progress() {
    # Detect in-progress actions (e.g. merge, rebase)
    # https://github.com/git/git/blob/v1.9-rc2/wt-status.c#L1199-L1241
    local git_dir="$(git rev-parse --git-dir)"

    if [ -f "$git_dir/MERGE_HEAD" ]; then
        echo " [merge]"
    elif [ -d "$git_dir/rebase-apply" ]; then
        [ -f "$git_dir/rebase-apply/applying" ] && echo " [am]" || echo " [rebase]"
    elif [ -d "$git_dir/rebase-merge" ]; then
        echo " [rebase]"
    elif [ -f "$git_dir/CHERRY_PICK_HEAD" ]; then
        echo " [cherry-pick]"
    fi
    [ -f "$git_dir/BISECT_LOG"  ] && echo " [bisect]"
    [ -f "$git_dir/REVERT_HEAD" ] && echo " [revert]"
}

sbp_is_branch1_behind_branch2 () {
    # Find the first log (if any) that is in branch1 but not branch2
    local first_log="$(git log $1..$2 -1 2> /dev/null)"
    [ -n "$first_log" ]
}

sbp_branch_exists () {
    # List remote branches and exit with 0 or 1
    git branch --remote 2> /dev/null | grep --quiet "$1"
}

sbp_has_remote () {
    [ $(git branch --remote 2> /dev/null | wc -l) -ne 0 ]
}

sbp_parse_git_ahead () {
    # Grab the local and remote branch
    local branch="$(sbp_get_git_branch)"
    local remote_branch="origin/$branch"

    # If the remote branch is behind the local branch
    # or it has not been merged into origin (remote branch doesn't exist)
    sbp_has_remote || return
    if (sbp_is_branch1_behind_branch2 "$remote_branch" "$branch" ||
            ! sbp_branch_exists "$remote_branch"); then
        echo 1
    fi
}

sbp_parse_git_behind () {
    # If the local branch is behind the remote branch
    sbp_is_branch1_behind_branch2 "$(sbp_get_git_branch)" "origin/$branch" && echo 1
}

function sbp_parse_git_dirty() {
    # If the git status has *any* changes (e.g. dirty), echo our character
    [ -n "$(git status --porcelain 2> /dev/null)" ] && echo 1
}

function sbp_is_on_git() {
    git rev-parse 2> /dev/null
}

function sbp_get_git_status() {
    # Grab the git dirty and git behind
    local dirty_branch="$(sbp_parse_git_dirty)"
    local branch_ahead="$(sbp_parse_git_ahead)"
    local branch_behind="$(sbp_parse_git_behind)"

    # Iterate through all the cases and if it matches, then echo
    if [[ "$dirty_branch" == 1 && "$branch_ahead" == 1 && "$branch_behind" == 1 ]]; then
        echo "$sbp_dirty_unpushed_unpulled_symbol"
    elif [[ "$branch_ahead" == 1 && "$branch_behind" == 1 ]]; then
        echo "$sbp_unpushed_unpulled_symbol"
    elif [[ "$dirty_branch" == 1 && "$branch_ahead" == 1 ]]; then
        echo "$sbp_dirty_unpushed_symbol"
    elif [[ "$branch_ahead" == 1 ]]; then
        echo "$sbp_unpushed_symbol"
    elif [[ "$dirty_branch" == 1 && "$branch_behind" == 1 ]]; then
        echo "$sbp_dirty_unpulled_symbol"
    elif [[ "$branch_behind" == 1 ]]; then
        echo "$sbp_unpulled_symbol"
    elif [[ "$dirty_branch" == 1 ]]; then
        echo "$sbp_dirty_synced_symbol"
    else # clean
        echo "$sbp_synced_symbol"
    fi
}

sbp_get_git_info () {
    local branch="$(sbp_get_git_branch)"
    [ -n "$branch" ] && echo "$(sbp_get_git_status)${branch}"
}

sbp_get_retval () {
    local retval=$? 
    [ $retval -ne 0 ] && echo -e "\033[1;31m✖ ${retval}"
}

# Define the sexy-bash-prompt
PS1="\$( sbp_get_retval;\
  echo -n \"\[$sbp_dir_color\]\w\"
  sbp_is_on_git && \
  echo -n \"\[$sbp_git_status_color\]\$(sbp_get_git_info)\" && \
  echo -n \"\[$sbp_git_progress_color\]\$(sbp_get_git_progress)\"\
)\[$sbp_reset\]\
\[$sbp_symbol_color\]$sbp_symbol\[$sbp_reset\]"


# TODO
# Use eval statement to resolves all the colours. Eval can be told not to resolve functions.
# The advantage is that the colours can then be taken out of the Bash global namespace
